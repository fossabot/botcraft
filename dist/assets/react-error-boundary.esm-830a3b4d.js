import{a as s}from"./react-1b326164.js";const h=s.createContext(null),i={didCatch:!1,error:null};class E extends s.Component{constructor(r){super(r),this.resetErrorBoundary=this.resetErrorBoundary.bind(this),this.state=i}static getDerivedStateFromError(r){return{didCatch:!0,error:r}}resetErrorBoundary(...r){const{error:e}=this.state;e!==null&&(this.props.onReset?.({args:r,reason:"imperative-api"}),this.setState(i))}componentDidCatch(r,e){this.props.onError?.(r,e)}componentDidUpdate(r,e){const{didCatch:t}=this.state,{resetKeys:o}=this.props;t&&e.error!==null&&p(r.resetKeys,o)&&(this.props.onReset?.({next:o,prev:r.resetKeys,reason:"keys"}),this.setState(i))}render(){const{children:r,fallbackRender:e,FallbackComponent:t,fallback:o}=this.props,{didCatch:l,error:c}=this.state;let n=r;if(l){const d={error:c,resetErrorBoundary:this.resetErrorBoundary};if(s.isValidElement(o))n=o;else if(typeof e=="function")n=e(d);else if(t)n=s.createElement(t,d);else throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop")}return s.createElement(h.Provider,{value:{didCatch:l,error:c,resetErrorBoundary:this.resetErrorBoundary}},n)}}function p(a=[],r=[]){return a.length!==r.length||a.some((e,t)=>!Object.is(e,r[t]))}export{E};
